---
title: "prueba"
output: html_document
date: "2024-02-21"
---

```{r cars}
final_df_er_sepsis_prueba <- read.csv("C:/Users/cjimenez10J/Documents/projects/r_urgencias_sepsis/r_urgencias_sepsis/Figures/selected_data.csv")
message("Datos cargados correctamente")
```

# Discretizar er_los_hrs

```{r}
# Discretizar la variable de tiempo en intervalos de una hora
final_df_er_sepsis$er_los_hrs_d <- cut(final_df_er_sepsis$er_los_hrs, breaks = seq(0,6, by = 1), labels = FALSE)
final_df_er_sepsis$er_los_hrs_d[final_df_er_sepsis$er_los_hrs == 0] <- 0
final_df_er_sepsis$er_los_hrs_d[final_df_er_sepsis$er_los_hrs == 6] <- 6
# Determinar la cantidad de individuos a seleccionar por cada intervalo
individuals_per_interval <- floor(950*table(final_df_er_sepsis$er_los_hrs_d) / max(table(final_df_er_sepsis$er_los_hrs_d)))
# Ver cuantas observaciones hay en cada hora
final_df_er_sepsis %>%
  group_by(er_los_hrs_d) %>%
  summarise(n = n())
# Seleccionar individuos manteniendo la distribución original
selected_sample <- final_df_er_sepsis %>%
  group_by(er_los_hrs_d) %>%
  sample(size = individuals_per_interval, replace = FALSE)
```

# GLM con 2 variables:mortalidad y er_los_uci

```{r}
# Crear un data frame con valores para graficar
plot_data <- data.frame(
  er_los_hrs = seq(min(final_df_er_sepsis$er_los_hrs), max(final_df_er_sepsis$er_los_hrs), by = 0.08)
)

# Agregar otras variables predictoras según sea necesario
#UNITDISCHARGESTATUS
plot_data$unitdischargestatus = predict(
  logistic_model, plot_data, type = "response"
)
tiempo <- seq(0,6,by = 0.08)
set.seed(40)

#SEX
sex_aleatorio <- sample(c("M", "F"), size = length(tiempo), replace = TRUE)
plot_data$sex <- sex_aleatorio

#AGE
plot_data$age <- mean(final_df_er_sepsis$age)

#ETHNICITY
ethnicity_aleatorio <- sample(c( "Caucasian","other/unknown"),size = length(tiempo), replace = TRUE)
plot_data$ethnicity <- ethnicity_aleatorio

#APACHESOCREIV
plot_data$apachescoreIV <- mean(final_df_er_sepsis$apachescoreIV)

#FINAL CHARLSON SCORE
plot_data$final_charlson_score <- mean(final_df_er_sepsis$final_charlson_score)

# Función para calcular la moda
calculate_mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

#HIST 
plot_data$hist_diabetes_bin <- calculate_mode(final_df_er_sepsis$hist_diabetes_bin)
plot_data$hist_renal_bin <- calculate_mode(final_df_er_sepsis$hist_renal_bin)
plot_data$hist_cancer_bin <- calculate_mode(final_df_er_sepsis$hist_cancer_bin)
plot_data$hist_chf_bin <- calculate_mode(final_df_er_sepsis$hist_chf_bin)
plot_data$hist_copd_bin <- calculate_mode(final_df_er_sepsis$hist_copd_bin)
plot_data$hist_other_bin <- calculate_mode(final_df_er_sepsis$hist_other_bin)

#APACHE ADMISSION DX
apacheadmission_aleatorio <- sample(c("Pneumonia, bacteria","Sepsis, GI","Sepsis, pulmonary","Sepsis, renal/UTI (including bladder) Sepsis, unknown","Other"),size = length(tiempo),replace = TRUE)
plot_data$apacheadmissiondx <- apacheadmission_aleatorio

#UNIT type
unittype_aleatorio <- sample(c("Med-Surg ICU","MICU","Other", "CCU-CTICU"), size = length(tiempo), replace = TRUE)
plot_data$unittype <- unittype_aleatorio

# Asegurarse de que los niveles de apacheadmissiondx sean los mismos
plot_data$apacheadmissiondx <- factor(plot_data$apacheadmissiondx, levels = levels(final_df_er_sepsis$apacheadmissiondx))

# Calcular valores predichos y intervalos de confianza
plot_data$predicted_prob <- predict(logreg_icudeath, newdata = plot_data, type = "response")

# Calcular valores predichos y intervalos de confianza
plot_data$predicted_prob <- predict(logreg_icudeath, newdata = plot_data, type = "response")
plot_data$OR <- exp(predict(logreg_icudeath, newdata = plot_data, type = "link"))

# Calcular intervalos de confianza
plot_data$lower_CI <- exp(predict(logreg_icudeath, newdata = plot_data, type = "link", se.fit = TRUE)$fit - 1.96 * predict(logreg_icudeath, newdata = plot_data, type = "link", se.fit = TRUE)$se.fit)
plot_data$upper_CI <- exp(predict(logreg_icudeath, newdata = plot_data, type = "link", se.fit = TRUE)$fit + 1.96 * predict(logreg_icudeath, newdata = plot_data, type = "link", se.fit = TRUE)$se.fit)


# Calcular las probabilidades predichas con el modelo de regresión logística
predicted_probs <- predict(logreg_icudeath, newdata = final_df_er_sepsis, type = "response")

# Crear un data frame con las variables de interés y las probabilidades predichas
plot_data <- data.frame(
  er_los_hrs = final_df_er_sepsis$er_los_hrs,
  unitdischargestatus = final_df_er_sepsis$unitdischargestatus,
  predicted_prob = predicted_probs
)

# Graficar la relación según el modelo
library(ggplot2)

ggplot(plot_data, aes(x = er_los_hrs, y = predicted_prob, color = as.factor(unitdischargestatus))) +
  geom_point() +
  geom_smooth(method = "glm", method.args = list(family = "binomial"), se = FALSE) +
  labs(
    x = "Emergency Room Length of Stay (hours)",
    y = "Predicted Probability of Unit Discharge",
    color = "Unit Discharge Status"
  ) +
  theme_minimal()

```
### Con df completo (final_df_er_sepsis_prueba)

```{r}
Predicted_data <- data.frame(er_los_hrs = seq(min(final_df_er_sepsis$er_los_hrs), max(final_df_er_sepsis$er_los_hrs), by = 0.08))

Predicted_data$unitdischargestatus = predict(
  logistic_model, Predicted_data, type = "response"
)

plot(unitdischargestatus ~ er_los_hrs, data = final_df_er_sepsis)
lines(unitdischargestatus ~ er_los_hrs, Predicted_data, lwd = 2, col = "blue")

predicciones3 <- predict(logistic_model, type = "response")
clases_predichas3 <- ifelse(predicciones3 > 0.5,1,0)
matriz_confusion3 <- table( Actual = final_df_er_sepsis$unitdischargestatu, predicha = clases_predichas)

precision3 <- (matriz_confusion3[2, 2] + matriz_confusion3[1, 1]) / sum(matriz_confusion3)
sensibilidad3 <- matriz_confusion3[2, 2] / sum(matriz_confusion3[2, ])
f1_score3 <- 2 * (precision3 * sensibilidad3) / (precision3 + sensibilidad3)
especificidad3 <- matriz_confusion3[1, 1] / sum(matriz_confusion3[1, ])
exactitud3 <- (matriz_confusion3[1, 1] + matriz_confusion3[2, 2]) / sum(matriz_confusion3)


# Muestra las métricas
cat("Precisión:", precision3, "\n")
cat("Sensibilidad:", sensibilidad3, "\n")
cat("Especificidad:", especificidad3, "\n")
cat("Exactitud:", exactitud3, "\n")
cat("F1 Score:", f1_score3, "\n")

```

### Con df balanceados
```{r}
# Obtén índices de todas las observaciones vivas y muertas
indices_todas_vivos_prueba <- which(final_df_er_sepsis_prueba$unitdischargestatus == 0)
indices_todas_muertos_prueba <- which(final_df_er_sepsis_prueba$unitdischargestatus == 1)

# Selecciona 900 vivos y 900 muertos para entrenamiento
indices_entrenamiento_vivos_prueba <- sample(indices_todas_vivos_prueba, size = 950, replace = FALSE)
indices_entrenamiento_muertos_prueba <- sample(indices_todas_muertos_prueba, size = 950, replace = FALSE)

# Combina los índices de vivos y muertos para el conjunto de entrenamiento
indices_entrenamiento_prueba <- c(indices_entrenamiento_vivos_prueba, indices_entrenamiento_muertos_prueba)

# Selecciona las observaciones de entrenamiento
data_entrenamiento_prueba <- final_df_er_sepsis_prueba[indices_entrenamiento_prueba, ]

# Verifica el balance de clases en el conjunto de entrenamiento
table(data_entrenamiento_prueba$unitdischargestatus)
logistic_model4 <- glm(unitdischargestatus ~ er_los_hrs,data = data_entrenamiento_prueba,
    family = binomial)

Predicted_data4 <- data.frame(er_los_hrs = seq(min(data_entrenamiento_prueba$er_los_hrs), max(data_entrenamiento_prueba$er_los_hrs), by = 0.08))

Predicted_data4$unitdischargestatus = predict(
  logistic_model4, Predicted_data4, type = "response"
)

plot(unitdischargestatus ~ er_los_hrs, data = data_entrenamiento_prueba)
lines(Predicted_data4$er_los_hrs, Predicted_data4$unitdischargestatus, lwd = 2, col = "blue")


predicciones4 <- predict(logistic_model4, type = "response")
clases_predichas4 <- ifelse(predicciones4 > 0.5,1,0)
matriz_confusion4 <- table( Actual = data_entrenamiento_prueba$unitdischargestatu, predicha = clases_predichas4)

precision4 <- (matriz_confusion4[2, 2] + matriz_confusion4[1, 1]) / sum(matriz_confusion4)
sensibilidad4 <- matriz_confusion4[2, 2] / sum(matriz_confusion4[2, ])
f1_score4 <- 2 * (precision4 * sensibilidad4) / (precision4 + sensibilidad4)
especificidad4 <- matriz_confusion4[1, 1] / sum(matriz_confusion4[1, ])
exactitud4 <- (matriz_confusion4[1, 1] + matriz_confusion4[2, 2]) / sum(matriz_confusion4)


# Muestra las métricas
cat("Precisión:", precision4, "\n")
cat("Sensibilidad:", sensibilidad4, "\n")
cat("Especificidad:", especificidad4, "\n")
cat("Exactitud:", exactitud4, "\n")
cat("F1 Score:", f1_score4, "\n")

```

# GLM multivariante

###  Con df completo (final_df_er_sepsis_prueba)

```{r}
logistic_model_2 <- glm(unitdischargestatus ~ er_los_hrs r_los_hrs + sex + age + ethnicity + apachescoreIV +  final_charlson_score + hist_diabetes_bin + hist_renal_bin + hist_cancer_bin + hist_chf_bin + hist_copd_bin + hist_other_bin + unittype + apacheadmissiondx,data = final_df_er_sepsis,
    family = binomial)

#ER_LOS_HRS
Predicted_data <- data.frame(er_los_hrs = seq(min(final_df_er_sepsis$er_los_hrs), max(final_df_er_sepsis$er_los_hrs), by = 0.08))

#UNITDISCHARGESTATUS
Predicted_data$unitdischargestatus = predict(
  logistic_model, Predicted_data, type = "response"
)
tiempo <- seq(0,6,by = 0.08)
set.seed(40)

#SEX
sex_aleatorio <- sample(c("M", "F"), size = length(tiempo), replace = TRUE)
Predicted_data$sex <- sex_aleatorio

#AGE
Predicted_data$age <- mean(final_df_er_sepsis$age)

#ETHNICITY
ethnicity_aleatorio <- sample(c( "Caucasian","other/unknown"),size = length(tiempo), replace = TRUE)
Predicted_data$ethnicity <- ethnicity_aleatorio

#APACHESOCREIV
Predicted_data$apachescoreIV <- mean(final_df_er_sepsis$apachescoreIV)

#FINAL CHARLSON SCORE
Predicted_data$final_charlson_score <- mean(final_df_er_sepsis$final_charlson_score)

# Función para calcular la moda
calculate_mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

#HIST 
Predicted_data$hist_diabetes_bin <- calculate_mode(final_df_er_sepsis$hist_diabetes_bin)
Predicted_data$hist_renal_bin <- calculate_mode(final_df_er_sepsis$hist_renal_bin)
Predicted_data$hist_cancer_bin <- calculate_mode(final_df_er_sepsis$hist_cancer_bin)
Predicted_data$hist_chf_bin <- calculate_mode(final_df_er_sepsis$hist_chf_bin)
Predicted_data$hist_copd_bin <- calculate_mode(final_df_er_sepsis$hist_copd_bin)
Predicted_data$hist_other_bin <- calculate_mode(final_df_er_sepsis$hist_other_bin)

#APACHE ADMISSION DX
Predicted_data$apacheadmissiondx_other <- calculate_mode(final_df_er_sepsis$apacheadmissiondx_other)
Predicted_data$apacheadmissiondx_pneumonia_bacterial <- calculate_mode(final_df_er_sepsis$apacheadmissiondx_pneumonia_bacterial)
Predicted_data$apacheadmissiondx_sepsis_gi <- calculate_mode(final_df_er_sepsis$apacheadmissiondx_sepsis_gi)
Predicted_data$apacheadmissiondx_sepsis_pulmonary <- calculate_mode(final_df_er_sepsis$apacheadmissiondx_sepsis_pulmonary)
Predicted_data$apacheadmissiondx_sepsis_renal_uti <- calculate_mode(final_df_er_sepsis$apacheadmissiondx_sepsis_renal_uti)
Predicted_data$apacheadmissiondx_sepsis_unknown <- calculate_mode(final_df_er_sepsis$apacheadmissiondx_sepsis_unknown)

#UNIT STAY
Predicted_data$unit_ccu_cticu <- calculate_mode(final_df_er_sepsis$unit_ccu_cticu)
Predicted_data$unit_med_surg_icu <- calculate_mode(final_df_er_sepsis$unit_med_surg_icu)
Predicted_data$unit_micu <- calculate_mode(final_df_er_sepsis$unit_micu)
Predicted_data$unit_other <- calculate_mode(final_df_er_sepsis$unit_other)


plot(unitdischargestatus ~ er_los_hrs,data = final_df_er_sepsis)
lines(unitdischargestatus ~ er_los_hrs, Predicted_data, lwd = 2, col = "blue")


# Predecir las probabilidades
predicted_probs <- predict(logistic_model_2, newdata = Predicted_data, type = "response")

# Convertir probabilidades a clases predichas (0 o 1)
predicted_classes <- ifelse(predicted_probs > 0.5, 1, 0)

# Crear la matriz de confusión
conf_matrix5 <- table(Predicted = predicted_classes, Actual = final_df_er_sepsis$unitdischargestatus)

# Calcular métricas
precision5 <- (conf_matrix5[2, 2] + conf_matrix5[1, 1]) / sum(conf_matrix5)
sensibilidad5 <- conf_matrix5[2, 2] / sum(conf_matrix5[2, ])
f1_score5 <- 2 * (precision5 * sensibilidad5) / (precision5 + sensibilidad5)
especificidad5 <- conf_matrix5[1, 1] / sum(conf_matrix5[1, ])
exactitud5 <- (conf_matrix5[1, 1] + conf_matrix5[2, 2]) / sum(conf_matrix5)

# Imprimir las métricas
cat("Sensibilidad:", sensibilidad5, "\n")
cat("Especificidad:", especificidad5, "\n")
cat("Exactitud:", exactitud5, "\n")
cat("Precisión:", precision5, "\n")
cat("F1 Score:", f1_score5, "\n")

```


### Con df completo train 80% y test 20%
```{r}

indices_todas_vivos <- which(final_df_er_sepsis$unitdischargestatus == 0)
indices_todas_muertos <- which(final_df_er_sepsis$unitdischargestatus == 1)

# Selecciona 950 vivos y 950 muertos para entrenamiento
indices_vivos <- sample(indices_todas_vivos, size = 950, replace = FALSE)
indices_muertos <- sample(indices_todas_muertos, size = 950, replace = FALSE)

# Combina los índices de vivos y muertos para el conjunto de entrenamiento
indices_balanceado <- c(indices_vivos, indices_muertos)

# Selecciona las observaciones de entrenamiento
data_balanceado <- final_df_er_sepsis[indices_balanceado, ]

# Verifica el balance de clases en el conjunto de entrenamiento
table(data_balanceado$unitdischargestatus)


set.seed(123)
indice_particion <- createDataPartition(data_balanceado$unitdischargestatus, p = 0.8, list = FALSE,times = 1)

conjunto_entrenamiento <- data_balanceado[indice_particion, ]
conjunto_prueba <- data_balanceado[-indice_particion, ]

##MODELO GLM
logistic_model_3 <- glm(unitdischargestatus ~ er_los_hrs + sex + age + ethnicity + apachescoreIV +  final_charlson_score + hist_diabetes_bin + hist_renal_bin + hist_cancer_bin + hist_chf_bin + hist_copd_bin + hist_other_bin + apacheadmissiondx_other + apacheadmissiondx_pneumonia_bacterial + apacheadmissiondx_sepsis_gi + apacheadmissiondx_sepsis_pulmonary + apacheadmissiondx_sepsis_renal_uti + apacheadmissiondx_sepsis_unknown + unit_ccu_cticu + unit_med_surg_icu + unit_micu + unit_other ,data = conjunto_entrenamiento,
    family = binomial)
 #+ apacheadmissiondx_sepsis_unknown + unit_other
##Predicciones
predicciones2 <- predict(logistic_model_3, newdata = conjunto_prueba, type = "response")

clases_predichas2 <- ifelse(predicciones2 > 0.5,1,0)

matriz_confusion2 <- confusionMatrix(table(conjunto_prueba$unitdischargestatus, clases_predichas2))
print(matriz_confusion2)

precision2 <- matriz_confusion2$byClass["Pos Pred Value"]
sensibilidad2 <- matriz_confusion2$byClass["Sensitivity"]
especificidad2 <- matriz_confusion2$byClass["Specificity"]
exactitud2 <- matriz_confusion2$overall["Accuracy"]
f1_score <- 2 * (precision2 * sensibilidad2) / (precision2 + sensibilidad2)


# Imprime las métricas
cat("Precisión:", precision2, "\n")
cat("Sensibilidad:", sensibilidad2, "\n")
cat("Especificidad:", especificidad2, "\n")
cat("Exactitud:", exactitud2, "\n")
cat("Puntaje F1:", f1_score, "\n")

# Calcula la curva ROC
curva_roc <- roc(conjunto_prueba$unitdischargestatus, predicciones2)

# Realiza el gráfico de la curva ROC
plot(curva_roc, main = "Curva ROC", col = "blue", lwd = 2)

# Opcional: Añade un punto para resaltar el rendimiento de tu modelo
#points(curva_roc, pch = 16, col = "red", cex = 1.5)

# Opcional: Etiqueta el punto resaltado
#text(curva_roc, col = "red", pos = 4, offset = 0.5, cex = 1.2)

# Añade una leyenda
legend("bottomright", legend = c("Curva ROC", "Modelo"), col = c("blue", "red"), lwd = c(2, 1))

# Imprime el área bajo la curva ROC
cat("Área bajo la curva ROC:", area_roc, "\n")
```


# GAM BALANCEADO 
División datos para balancear valores muertes y vivos

```{r}
#Semilla para reproducibilidad
set.seed(123)

########### TRAIN
# Obtén índices de todas las observaciones vivas y muertas
indices_todas_vivos <- which(final_df_er_sepsis$unitdischargestatus == 0)
indices_todas_muertos <- which(final_df_er_sepsis$unitdischargestatus == 1)

# Selecciona 900 vivos y 900 muertos para entrenamiento
indices_entrenamiento_vivos <- sample(indices_todas_vivos, size = 900, replace = FALSE)
indices_entrenamiento_muertos <- sample(indices_todas_muertos, size = 900, replace = FALSE)

# Combina los índices de vivos y muertos para el conjunto de entrenamiento
indices_entrenamiento <- c(indices_entrenamiento_vivos, indices_entrenamiento_muertos)

# Selecciona las observaciones de entrenamiento
data_entrenamiento <- final_df_er_sepsis[indices_entrenamiento, ]

# Verifica el balance de clases en el conjunto de entrenamiento
table(data_entrenamiento$unitdischargestatus)


########## TEST
# Obtén índices de todas las observaciones vivas y muertas
indices_vivos <- which(final_df_er_sepsis$unitdischargestatus == 0)
indices_muertos <- which(final_df_er_sepsis$unitdischargestatus == 1)

# Selecciona 900 vivos y 900 muertos para entrenamiento
indices_test_vivos <- sample(indices_vivos, size = 50, replace = FALSE)
indices_test_muertos <- sample(indices_muertos, size = 50, replace = FALSE)

# Combina los índices de vivos y muertos para el conjunto de entrenamiento
indices_test <- c(indices_test_vivos, indices_test_muertos)

# Selecciona las observaciones de entrenamiento
data_test <- final_df_er_sepsis[indices_test, ]

# Verifica el balance de clases en el conjunto de entrenamiento
table(data_test$unitdischargestatus)

###### GAM
gam_data_train <- 
  gam(
    unitdischargestatus ~ s(er_los_hrs, k=3) + sex + age + ethnicity + apachescoreIV +  final_charlson_score + hist_diabetes_bin + hist_renal_bin + hist_cancer_bin + hist_chf_bin + hist_copd_bin + hist_other_bin + apacheadmissiondx_other + apacheadmissiondx_pneumonia_bacterial + apacheadmissiondx_sepsis_gi + apacheadmissiondx_sepsis_pulmonary + apacheadmissiondx_sepsis_renal_uti + apacheadmissiondx_sepsis_unknown + unit_ccu_cticu + unit_med_surg_icu + unit_micu + unit_other, data = data_entrenamiento,
    family = binomial)


# Make predictions on the test data
data_test$predicted <- predict(gam_data_train, newdata = data_test, type = "response")
data_test$predicted_bin <- ifelse(data_test$predicted > 0.5, 1, 0)

# Calculate precision, recall, and F1 score
precision <- sum(data_test$predicted_bin == 1 & data_test$unitdischargestatus == 1) / sum(data_test$predicted_bin == 1)
recall <- sum(data_test$predicted_bin == 1 & data_test$unitdischargestatus == 1) / sum(data_test$unitdischargestatus == 1)
f1 <- 2 * precision * recall / (precision + recall)

# Print the results
print(precision)
print(recall)
print(f1)

coef_data <- data.frame(coef = coef(gam_data_train))
se <- sqrt(diag(vcov(gam_data_train)))
z_value <- qnorm(0.95) # 95% confidence level - detection prevalence
#Redondea decimales a 2

coef_data <- round(coef_data, 2)

# Calculate the odds ratios and their respective lower and upper confidence limits
coef_data$OR <- exp(coef_data$coef)
coef_data$OR_lower <- exp(coef_data$coef - z_value * se)  # Usar 0.975 para obtener IC del 95%
coef_data$OR_upper <- exp(coef_data$coef + z_value * se)

# Filtrar las variables de interés
#coef_data2 <- coef_data %>%
#  filter(predictor != "(Intercept)")

# Calcular la categoría (Adverse, Protective, Inconclusive)
coef_data <- coef_data %>%
  mutate(
    adverse_protective = case_when(
      OR_lower > 1 & OR_upper > 1 ~ "Adverse",
      OR_lower < 1 & OR_upper < 1 ~ "Protective",
      TRUE ~ "Inconclusive"
    )
  )
coef_data$adverse_protective <- as.factor(coef_data$adverse_protective)

# Crear el forest plot
forest_plot <- ggplot(coef_data, aes(x = OR, xmin = OR_lower, xmax = OR_upper, y = rownames(coef_data))) +
  geom_point(aes(color = adverse_protective), size = 3) +
  geom_errorbarh(aes(color = adverse_protective), height = 0.1, linewidth = 0.5) +
  geom_vline(xintercept = 1, linetype = "solid", color = "gray50") +
  labs(
    x = "Odds Ratio (with 95% Confidence Interval)",
    y = "Predictor Variable",
    title = "Odds Ratios and Confidence Intervals for mortality emergency sepsis ICU"
  ) +
  scale_color_manual(values = c("Adverse" = "#c0392b", "Protective" = "#27ae60", "Inconclusive" = "gray70")) +
  theme_minimal() 

print(forest_plot)


# Variable er_los_hrs
gam_plot <-plot(gam_data_train, rug = TRUE,scale = 0)
x <- gam_plot[[1]]$x
fit <- gam_plot[[1]]$fit
se <- gam_plot[[1]]$se

fit_values <- as.vector(fit)
se_values <- as.vector(se)


# Convert odds ratio to percentage chance of ICU mortality 
fit_chance <- (exp(fit) / (1 + exp(fit))) 
lower_bound_chance <- (exp(fit - 2 * se) / (1 + exp(fit - 2 * se))) 
upper_bound_chance <- (exp(fit + 2 * se) / (1 + exp(fit + 2 * se))) 


df_train <- 
  data.frame(
    x = x, y = fit_chance,
    ymin = lower_bound_chance , ymax = upper_bound_chance
  )

ggplot(df_train, mapping = aes(x = x, y = fit_chance)) +
  geom_ribbon(aes(ymin = lower_bound_chance, ymax = upper_bound_chance), alpha = 0.3) +
  geom_line(color = "blue") +  # Añade la línea de ajuste
  labs(
    x = "Emergency Room Length of Stay (hours)", 
    y = "Mortality in the ICU probability (%)", 
    title = "Generative Additive Modeling"
  ) +
  theme_minimal() +
  theme(
    strip.text = element_text(face = "italic"),
    panel.border = element_rect(color = "black", fill = NA, size = 0.6),
    legend.position = "none"
  ) +
  ylim(0.2, 1)

ggplot(df_train, mapping = aes(x = x, y = fit_chance)) +
  stat_smooth(method = gam, formula = y ~ s(x)) +
  geom_ribbon(aes(ymin = lower_bound_chance, ymax = upper_bound_chance), alpha = 0.3) +
   labs(
    x = "Emergency Room Length of Stay (hours)", 
    y = "Mortality in the ICU probability (%)", 
    title = "Generative Additive Modeling"
  ) +
  theme_minimal()
```

#PRIMER GAM

## FÓRMULA GAM

```{r}
#JUSTIFICACIÓN DE LA NO LINEALIDAD. Nos fijamos en la significación y en el Estimated degrees of freedom >1. Se utiliza para evaluar si la relación entre la variable de respuesta (unitdischargestatus: vivo o muerto) y la variable explicativa (er_los_hrs: tiempo en urgencias) es esencialmente lineal o si hay evidencias de no linealidad que podría ser capturada por la inclusión de términos suavizados

linear_model <- gam(unitdischargestatus ~ sex + age + ethnicity + apachescoreIV +  final_charlson_score + hist_diabetes_bin + hist_renal_bin + + hist_cancer_bin + hist_chf_bin + hist_copd_bin + hist_other_bin+ apacheadmissiondx  + vasopressors, data = final_df_er_sepsis,
    family = binomial)

gam_mortality_unit <- 
  gam(
    unitdischargestatus ~ s(er_los_hrs, bs="bs") + s(age, k=3) + sex + ethnicity + apachescoreIV +  final_charlson_score + hist_diabetes_bin + hist_renal_bin + + hist_cancer_bin + hist_chf_bin + hist_copd_bin + hist_other_bin+ apacheadmissiondx + bact_resist_level + vasopressors , data = final_df_er_sepsis,
    family = binomial)   

anova(linear_model, prueba_gam, test = "Chisq")

print(prueba_gam)
plot(gam_mortality_unit, rug = TRUE, shade = TRUE, shade.col = "lightblue")

plot(gam_mortality_unit, seWithMean = TRUE,shift = coef(gam_mortality_unit)[1], rug = TRUE, shade = TRUE, shade.col = "lightblue")

# seWithMean:A menudo es útil representar los errores estándar de un término de efecto parcial combinados con los errores estándar de la intersección del modelo. Esto se debe a que los intervalos de confianza en el valor medio de una variable pueden ser muy pequeños y no reflejan la incertidumbre general en nuestro modelo. El uso del argumento seWithMean añade esta incertidumbre.

# shift = coef(gam_mortality_unit)[1]: Para que los gráficos sean aún más interpretables, es útil cambiar la escala para que se incluya la intersección. Usando el argumento shift, podemos cambiar la escala por el valor de la intersección, que es el primer coeficiente del modelo. Observe cómo ha cambiado el eje Y. Ahora, el gráfico de efecto parcial tiene una interpretación más natural: nos muestra la predicción de la salida, asumiendo que otras variables están en su valor promedio.

#La variable “s(er_los_hrs:1.8)” parece ser una transformación suavizada de “er_los_hrs” que se utiliza en el modelo binomial con función de enlace logit para predecir la variable “unitdischargestatus” en función de varias variables independientes, incluyendo “sex”, “age”, “ethnicity”, “apachescoreIV”, “final_charlson_score”, “hist_diabetes_bin”, “hist_renal_bin”, “hist_cancer_bin”, “hist_chf_bin”, “hist_copd_bin”, “hist_other_bin”, “unittype” y “apacheadmissiondx”. La escala del eje Y, que va desde -0.4 a 0.2, representa los valores transformados suavizados del tiempo pasado en la sala de emergencias.

#La transformación suavizada se realiza mediante una función de suavizado que se ajusta a los datos de “er_los_hrs” y produce una curva suave que se ajusta a los datos. La función de suavizado utilizada en este caso parece tener 1.8 grados de libertad. La escala del eje Y se establece en función de los valores transformados suavizados de “er_los_hrs” y no de los valores originales de “er_los_hrs”.

```


## Odds Ratio and forest plot df total
The model's coefficients, odds ratios, and corresponding confidence intervals were then extracted to generate a forest plot, offering a concise visual representation of the estimated odds ratios and their precision intervals for each predictor variable. The GAM approach provides a robust framework to explore the complex relationships between multiple predictors and a binary health outcome, facilitating a comprehensive analysis in the field of public health research.

```{r}
## Extracción de Odds Ratio (OR)
or_icudeath_gam <- extract_coef_pval_OR(gam_mortality_unit)

## Ordenación de variables y asignación de nombres adecuados
variables_order <- rev(c(
  "Intercept", "Tiempo de ingreso en UCI (horas)", "Sex (Male)", "Age (years)", "Ethnicity", "ApachescoreIV", "Final Charlson Score", "Diabetes History", "Renal History", "Cancer History", "CHF History", "COPD History", "Other History"
))

or_icudeath_gam2 <- or_icudeath_gam %>%
  mutate(
    term = case_when(
      term == "(Intercept)" ~ "Intercept",
      term == "er_los_hrs" ~ "Tiempo de ingreso en UCI (horas)",
      term == "sex" ~ "Sex (Male)",
      term == "age" ~ "Age (years)",
      term == "ethnicity" ~ "Ethnicity",
      term == "apachescoreIV" ~ "ApachescoreIV",
      term == "final_charlson_score" ~ "Final Charlson Score",
      term == "hist_diabetes_bin" ~ "Diabetes History",
      term == "hist_renal_bin" ~ "Renal History",
      term == "hist_cancer_bin" ~ "Cancer History",
      term == "hist_chf_bin" ~ "CHF History",
      term == "hist_copd_bin" ~ "COPD History",
      term == "hist_other_bin" ~ "Other History",
      #term == "apacheadmissiondx" ~ "Apacheadmissiondx",
      #term == "bact_resist_level" ~ "Bact resist level",
      TRUE ~ as.character(term)
    ),
    adverse_protective_gam = case_when(
      OR_lower > 1 & OR_upper > 1 ~ "Adverse",
      OR_lower < 1 & OR_upper < 1 ~ "Protective",
      OR_lower <= 1 & OR_upper >= 1 ~ "Inconclusive"
    ),
    adverse_protective_gam = factor(adverse_protective_gam, levels = c("Adverse", "Protective", "Inconclusive"))
  ) %>%
  filter(term != "Intercept")  # Filtrar si es necesario


## Escritura de resultados en CSV
#write.csv(or_icudeath_2, "C:/Users/cjimenez10J/Documents/projects/r_urgencias_sepsis/r_urgencias_sepsis/Figures/or_icudeath_2.csv")

## Impresión de resultados en formato HTML y exportación de una tabla kable
#htmlTable(or_icudeath_2[,c("term", "OR", "OR_lower", "OR_upper")], caption = "Logistic Regression. Odds Ratio and Confidence Intervals for ICU Mortality-associated Factors. eICU Database")

or_table_gam <- or_icudeath_gam2 %>%
  select(term, OR, OR_lower, OR_upper) %>%
  mutate(
    term = factor(term, levels = variables_order),
    OR_upper = ifelse(OR_upper <= 100, sprintf("%.2f", OR_upper), sprintf("%.2f", OR_upper))
  ) %>%
  arrange(desc(term)) %>%
  kbl(caption = "GAM model. Odds Ratio and Confidence Intervals for ICU Mortality-associated Factors. eICU Database", align = "c") %>%
  kable_classic_2(full_width = F, html_font = "Cambria")

write.csv(or_table_gam, "C:/Users/cjimenez10J/Documents/projects/r_urgencias_sepsis/r_urgencias_sepsis/Figures/or_icudeath_gam2_eicu.csv")

## Create a data frame with all possible levels for adverse-protective-inconclusive variable
adverse_protective_levels_gam <- data.frame(adverse_protective = c("Adverse", "Protective", "Inconclusive"))

# Build the Forest plot
ggplot(or_icudeath_gam2, 
       aes(x = OR, xmin = OR_lower, xmax = OR_upper, y = term)) +
  geom_point(size = 2, aes(color = adverse_protective_gam)) +
  geom_errorbarh(height = 0.2, aes(color = adverse_protective_gam)) +
  geom_vline(xintercept = 1, linetype = "dashed") +
  labs(x = "Odds Ratio", y = NULL, title = "GAM model. Odds Ratio and Confidence Intervals\nfor Hospital Mortality-associated Factors. eICU Database") +
  theme_minimal() +
  scale_color_manual(
    values = c("#c0392b", "#27ae60", "gray70"),
    labels = c("Adverse", "Protective", "Inconclusive"),
    name = "Effect on Outcome",
    limits = adverse_protective_levels_gam$adverse_protective_gam) + #establishes limits of color scale
  scale_x_continuous(limits = c(0.5, 3)) +
  theme(
    plot.background = element_rect(fill = "white"),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(),
    plot.title = element_text(hjust = 0.5),
    legend.position = "top",
    axis.ticks = element_blank(),
    axis.text.x = element_text(color = "#2c3e50"),
    axis.text.y = element_text(color = "#2c3e50"
    ))
```

## GAM plot
Explicación gráficas:
EJE Y
1º Gráfica (gam_plot_mortality_unit): representa el fit (logaritmo de razón de probabilidad) es la manera en que el modelo GAM representa la relación entre la variable predictora 'er_los_hrs' y la variable respuesta 'mortalidad' (unitdischargestatus). Ofrece resultados directos de la estimación del GAM. INTERPRETACIÓN: Un valor negativo de fit indica una disminución en el logaritmo de la razón de probabilidades, lo que podría asociarse con una disminución en la probabilidad de mortalidad. Un valor positivo indica un aumento en la probabilidad logarítmica de mortalidad.
2º Grágica (df_er_los_hrs_mortality): representa fit_chance (probabilidad tras la transformación logística).Uso de fórmula sigmoide, valores entre 0 y 1

```{r}
# Variable er_los_hrs
gam_plot_mortality_unit <-plot(gam_mortality_unit, rug = TRUE,scale = 0)
x <- gam_plot_mortality_unit[[1]]$x
fit <- gam_plot_mortality_unit[[1]]$fit
se <- gam_plot_mortality_unit[[1]]$se

fit_values <- as.vector(fit)
se_values <- as.vector(se)


# Convert odds ratio to percentage chance of ICU mortality 
fit_chance <- (exp(fit) / (1 + exp(fit))) 
lower_bound_chance <- (exp(fit - 2 * se) / (1 + exp(fit - 2 * se))) 
upper_bound_chance <- (exp(fit + 2 * se) / (1 + exp(fit + 2 * se))) 


df_er_los_hrs_mortality <- 
  data.frame(
    x = x, y = fit_chance,
    ymin = lower_bound_chance , ymax = upper_bound_chance
  )

ggplot(df_er_los_hrs_mortality, mapping = aes(x = x, y = fit_chance)) +
  geom_ribbon(aes(ymin = lower_bound_chance, ymax = upper_bound_chance), alpha = 0.3) +
  geom_line(color = "blue") +  # Añade la línea de ajuste
  labs(
    x = "Emergency Room Length of Stay (hours)", 
    y = "Mortality in the ICU probability (%)", 
    title = "Generative Additive Modeling"
  ) +
  theme_minimal() +
  theme(
    strip.text = element_text(face = "italic"),
    panel.border = element_rect(color = "black", fill = NA, size = 0.6),
    legend.position = "none"
  ) +
  ylim(0.2, 1)

ggplot(df_er_los_hrs_mortality, mapping = aes(x = x, y = fit_chance)) +
  stat_smooth(method = gam, formula = y ~ s(x)) +
  geom_ribbon(aes(ymin = lower_bound_chance, ymax = upper_bound_chance), alpha = 0.3) +
   labs(
    x = "Emergency Room Length of Stay (hours)", 
    y = "Mortality in the ICU probability (%)", 
    title = "Generative Additive Modeling"
  ) +
  theme_minimal()

final_df_er_sepsis %>%
  ggplot(aes(x = er_los_hrs, y = unitdischargestatus)) +
  geom_point() +
  geom_smooth(
    method = "glm", method.args = list(family = "binomial"), 
    color = "dodgerblue", lty = 2, se = FALSE
  )
```

# GLM VERDADERO

```{r}
## Imprime el título y hora actual
print('Logistic Regression of hospital mortality')

## Ajuste del modelo de regresión logística
logreg_icudeath <- glm(
   unitdischargestatus ~ er_los_hrs + sex + age + ethnicity + apachescoreIV +  final_charlson_score + hist_diabetes_bin + hist_renal_bin + hist_cancer_bin + hist_chf_bin + hist_copd_bin + hist_other_bin + apacheadmissiondx + bact_resist_level + vasopressors, data = final_df_er_sepsis,
    family = binomial(link = "logit"))
```

##Odds ratio and forest plot

```{r}
## Extracción de Odds Ratio (OR)
or_icudeath_1 <- extract_coef_pval_OR(logreg_icudeath)

## Ordenación de variables y asignación de nombres adecuados
variables_order <- rev(c(
  "Intercept", "Tiempo de ingreso en UCI (horas)", "Sex (Male)", "Age (years)", "Ethnicity", "ApachescoreIV", "Final Charlson Score", "Diabetes History", "Renal History", "Cancer History", "CHF History", "COPD History", "Other History", "Apacheadmissiondx","Bact resist level"
))

or_icudeath_2 <- or_icudeath_1 %>%
  mutate(
    term = case_when(
      term == "(Intercept)" ~ "Intercept",
      term == "er_los_hrs" ~ "Tiempo de ingreso en UCI (horas)",
      term == "sex" ~ "Sex (Male)",
      term == "age" ~ "Age (years)",
      term == "ethnicity" ~ "Ethnicity",
      term == "apachescoreIV" ~ "ApachescoreIV",
      term == "final_charlson_score" ~ "Final Charlson Score",
      term == "hist_diabetes_bin" ~ "Diabetes History",
      term == "hist_renal_bin" ~ "Renal History",
      term == "hist_cancer_bin" ~ "Cancer History",
      term == "hist_chf_bin" ~ "CHF History",
      term == "hist_copd_bin" ~ "COPD History",
      term == "hist_other_bin" ~ "Other History",
      term == "apacheadmissiondx" ~ "Apacheadmissiondx",
      term == "bact_resist_level" ~ "Bact resist level",
      TRUE ~ as.character(term)
    ),
    adverse_protective_glm = case_when(
      OR_lower > 1 & OR_upper > 1 ~ "Adverse",
      OR_lower < 1 & OR_upper < 1 ~ "Protective",
      OR_lower <= 1 & OR_upper >= 1 ~ "Inconclusive"
    ),
    adverse_protective_glm = factor(adverse_protective_glm, levels = c("Adverse", "Protective", "Inconclusive"))
  ) %>%
  filter(term != "Intercept")  # Filtrar si es necesario


## Escritura de resultados en CSV
#write.csv(or_icudeath_2, "C:/Users/cjimenez10J/Documents/projects/r_urgencias_sepsis/r_urgencias_sepsis/Figures/or_icudeath_2.csv")

## Impresión de resultados en formato HTML y exportación de una tabla kable
#htmlTable(or_icudeath_2[,c("term", "OR", "OR_lower", "OR_upper")], caption = "Logistic Regression. Odds Ratio and Confidence Intervals for ICU Mortality-associated Factors. eICU Database")

or_table_glm <- or_icudeath_2 %>%
  select(term, OR, OR_lower, OR_upper) %>%
  mutate(
    term = factor(term, levels = variables_order),
    OR_upper = ifelse(OR_upper <= 100, sprintf("%.2f", OR_upper), sprintf("%.2f", OR_upper))
  ) %>%
  arrange(desc(term)) %>%
  kbl(caption = "Logistic Regression. Odds Ratio and Confidence Intervals for ICU Mortality-associated Factors. eICU Database", align = "c") %>%
  kable_classic_2(full_width = F, html_font = "Cambria")

write.csv(or_table_glm, "C:/Users/cjimenez10J/Documents/projects/r_urgencias_sepsis/r_urgencias_sepsis/Figures/or_icudeath_2_eicu.csv")

## Create a data frame with all possible levels for adverse-protective-inconclusive variable
adverse_protective_levels_glm <- data.frame(adverse_protective = c("Adverse", "Protective", "Inconclusive"))

# Build the Forest plot
ggplot(or_icudeath_2, 
       aes(x = OR, xmin = OR_lower, xmax = OR_upper, y = term)) +
  geom_point(size = 2, aes(color = adverse_protective_glm)) +
  geom_errorbarh(height = 0.2, aes(color = adverse_protective_glm)) +
  geom_vline(xintercept = 1, linetype = "dashed") +
  labs(x = "Odds Ratio", y = NULL, title = "Logistic Regression. Odds Ratio and Confidence Intervals\nfor Hospital Mortality-associated Factors. eICU Database") +
  theme_minimal() +
  scale_color_manual(
    values = c("#c0392b", "#27ae60", "gray70"),
    labels = c("Adverse", "Protective", "Inconclusive"),
    name = "Effect on Outcome",
    limits = adverse_protective_levels_glm$adverse_protective_glm) + #establishes limits of color scale
  scale_x_continuous(limits = c(0.5, 2)) +
  theme(
    plot.background = element_rect(fill = "white"),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(),
    plot.title = element_text(hjust = 0.5),
    legend.position = "top",
    axis.ticks = element_blank(),
    axis.text.x = element_text(color = "#2c3e50"),
    axis.text.y = element_text(color = "#2c3e50"
    ))
```

## Gráfico ggplot2

## Plot glm (PRESENTACIÓN) multivariante

```{r}
plot_logreg_icudeath <- final_df_er_sepsis %>%
  ggplot(aes(x = er_los_hrs, y = plogis(predict(logreg_icudeath, newdata = .)), color = unitdischargestatus)) +
  geom_smooth(method = "glm", se = TRUE, level = 0.95, aes(fill = unitdischargestatus), alpha = 0.3) +
  labs(title = "Logistic Regression Plot") +
  theme_bw() +
  theme(plot.title = element_text(face = "bold", hjust = 0.5))

print(plot_logreg_icudeath)
```

## Plot glm bivariable

```{r}
logistic_model <- glm(unitdischargestatus ~ er_los_hrs ,data = final_df_er_sepsis,
    family = binomial)

stargazer(logistic_model, type = "text")

p1 <- final_df_er_sepsis %>%
  ggplot(aes(x = er_los_hrs, y = unitdischargestatus)) +
# geom_point(colour = "black") +
  geom_smooth(method = "glm", se = TRUE, level = 0.95) +
  labs(title = "Logistic Regression Plot") +
  theme_bw() +
  theme(plot.title = element_text(face = "bold", hjust = 0.5))

print(p1)
```

## Regresión con variables significativas (selección de características) según resultados del modelo anterior 

```{r}
logreg_icudeath_seleccion <- glm(
   unitdischargestatus ~ er_los_hrs + age + apacheadmissiondx + hist_other_bin + hist_cancer_bin + hist_diabetes_bin + final_charlson_score + apachescoreIV, data = final_df_er_sepsis,
    family = binomial(link = "logit"))
summary(logreg_icudeath_seleccion)

predic_seleccion <- predict(logreg_icudeath_seleccion, type = "response")
clases_predichas_seleccion <- ifelse(predic_seleccion > 0.5,1,0)
matriz_confusion_seleccion <- table( Actual = final_df_er_sepsis$unitdischargestatus, predicha = clases_predichas_seleccion)
precission_seleccion <- (matriz_confusion_seleccion[2, 2] + matriz_confusion_seleccion[1, 1]) / sum(matriz_confusion_seleccion)
recall_seleccion <- matriz_confusion_seleccion[2, 2] / sum(matriz_confusion_seleccion[2, ])
f1_score_seleccion <- 2 * (precission_seleccion * recall_seleccion) / (precission_seleccion + recall_seleccion)

especificidad_seleccion <- matriz_confusion_seleccion[1, 1] / sum(matriz_confusion_seleccion[1, ])
exactitud_seleccion <- (matriz_confusion_seleccion[1, 1] + matriz_confusion_seleccion[2, 2]) / sum(matriz_confusion_seleccion)


print(precission_seleccion)
print(recall_seleccion)
print(f1_score_seleccion)
print(especificidad_seleccion)
print(exactitud_seleccion)
print(matriz_confusion_seleccion)
```

### Variable sensitivity:level, change na = no infection

```{r}
final_df <- final_df %>%
  mutate(
    bact_resist_level = replace_na(final_df$bact_resist_level, 'Not infection')
  )

final_df <- final_df %>%
  mutate(bact_resist_level = dplyr::recode(bact_resist_level, "No infection" = "Not infection"))
```

### History.dx. 

```{r}
final_df<- final_df %>%
  mutate(hist_metastasis_bin = replace_na(hist_metastasis_bin, 0)) %>%
  mutate(hist_vih_sida_bin = replace_na(hist_vih_sida_bin, 0)) %>%
  mutate(hist_cirrosis_liver_bin = replace_na(hist_cirrosis_liver_bin, 0)) %>%
  mutate(hist_stroke_bin = replace_na(hist_stroke_bin, 0)) %>%
  mutate(hist_renal_bin = replace_na(hist_renal_bin, 0)) %>%
  mutate(hist_diabetes_bin = replace_na(hist_diabetes_bin, 0)) %>%
  mutate(hist_cancer_bin = replace_na(hist_cancer_bin, 0)) %>%
  mutate(hist_leukemia_bin = replace_na(hist_leukemia_bin, 0)) %>%
  mutate(hist_lymphoma_bin = replace_na(hist_lymphoma_bin, 0)) %>%
  mutate(hist_myocardial_infar_bin = replace_na(hist_myocardial_infar_bin, 0)) %>%
  mutate(hist_chf_bin = replace_na(hist_chf_bin, 0)) %>%
  mutate(hist_pvd_bin = replace_na(hist_pvd_bin, 0)) %>%
  mutate(hist_tia_bin = replace_na(hist_tia_bin, 0)) %>%
  mutate(hist_dementia_bin = replace_na(hist_dementia_bin, 0)) %>%
  mutate(hist_copd_bin = replace_na(hist_copd_bin, 0)) %>%
  mutate(hist_ctd_bin = replace_na(hist_ctd_bin, 0)) %>%
  mutate(hist_pud_bin = replace_na(hist_pud_bin, 0)) %>%
  mutate(hist_liver_bin = replace_na(hist_liver_bin, 0))
```

```{r}
# Lista de variables
variables <- c("hist_metastasis_bin", "hist_vih_sida_bin", "hist_cirrosis_liver_bin", "hist_stroke_bin", 
               "hist_renal_bin", "hist_diabetes_bin", "hist_cancer_bin", "hist_leukemia_bin", 
               "hist_lymphoma_bin", "hist_myocardial_infar_bin", "hist_chf_bin", "hist_pvd_bin", 
               "hist_tia_bin", "hist_copd_bin", "hist_ctd_bin", 
               "hist_pud_bin", "hist_liver_bin") #

# Utilizar dplyr para realizar el conteo y seleccionar las cinco variables con más 1
top5_hist_dx <- final_df %>%
  select(all_of(variables)) %>%
  summarise(across(everything(), ~sum(. == 1), .names = "Conteo_{.col}")) %>%
  pivot_longer(everything(), names_to = "Variable", values_to = "Conteo") %>%
  arrange(desc(Conteo)) %>%
  head(5)

# Mostrar el resultado final
print(top5_hist_dx)

# Agrupar resto de hist en una misma variable other
## Columna de cada pacientes donde se indica el total de cormobilidades que tiene cada uno de ellos
final_df <- final_df %>%
  mutate(hist_other = rowSums(select(., starts_with("hist_")) == 1))

## Columna de cada paciente codificada en 0 y 1, 0 sino tiene nada , 1 si tiene 1 o más cormobilidades
final_df <- final_df %>%
  mutate(hist_other_bin = ifelse(hist_other == 0, 0, 1))

```

##GAM SIMPLE (SIN INTERACCIÓN DE VASOPRESORES)

```{r}
gam_simple <- bam(unitdischargestatus ~ 
                    s(er_los_hrs, k=3) + 
                    vasopressors +
                    sex + 
                    age +
                    ethnicity + 
                    apachescoreIV +  
                    final_charlson_score,
                  data = final_df_er_sepsis,
                  family = binomial)

plot1 <- marginaleffects::plot_predictions(gam_simple, condition = c("er_los_hrs")) + 
  theme_bw() + 
  labs(x = "Time from admission (hours)",
       y = "Predicted probability of death") + 
  ylim(0, 0.5)

ggsave("C:/Users/cjimenez10J/Documents/projects/r_urgencias_sepsis/r_urgencias_sepsis/Figures/plot_gam_vaso.png", plot = plot1, width = 8, height = 6)



linear_model <- gam(unitdischargestatus ~ sex + age + ethnicity + apachescoreIV +  final_charlson_score + vasopressors, data = final_df_er_sepsis,
    family = binomial)

anova(linear_model, gam_simple, test = "Chisq")
print(gam_simple)
```


###FOREST PLOT

```{r}
## Extracción de Odds Ratio (OR)
or_icudeath_gam <- extract_coef_pval_OR(gam_simple)

## Ordenación de variables y asignación de nombres adecuados
variables_order <- rev(c(
  "Intercept", "Tiempo de ingreso en UCI (horas)", "Sex (Male)", "Age (years)", "Ethnicity", "ApachescoreIV", "Final Charlson Score", "Use of Vasopressors"
))

or_icudeath_gam2 <- or_icudeath_gam %>%
  mutate(
    term = case_when(
      term == "(Intercept)" ~ "Intercept",
      term == "er_los_hrs" ~ "Tiempo de ingreso en UCI (horas)",
      term == "sex" ~ "Sex (Male)",
      term == "age" ~ "Age (years)",
      term == "ethnicity" ~ "Ethnicity",
      term == "apachescoreIV" ~ "ApachescoreIV",
      term == "final_charlson_score" ~ "Final Charlson Score",
      term == "vasopressors" ~ "Use of Vasopressors",
      #term == "apacheadmissiondx" ~ "Apacheadmissiondx",
      #term == "bact_resist_level" ~ "Bact resist level",
      TRUE ~ as.character(term)
    ),
    adverse_protective_gam = case_when(
      OR_lower >= 1 & OR_upper >= 1 ~ "Adverse",
      OR_lower <= 1 & OR_upper <= 1 ~ "Protective",
      OR_lower <= 1 & OR_upper >= 1 ~ "Inconclusive"
    ),
    adverse_protective_gam = factor(adverse_protective_gam, levels = c("Adverse", "Protective", "Inconclusive"))
  ) %>%
  filter(term != "Intercept")  # Filtrar si es necesario


## Escritura de resultados en CSV
#write.csv(or_icudeath_2, "C:/Users/cjimenez10J/Documents/projects/r_urgencias_sepsis/r_urgencias_sepsis/Figures/or_icudeath_2.csv")

## Impresión de resultados en formato HTML y exportación de una tabla kable
#htmlTable(or_icudeath_2[,c("term", "OR", "OR_lower", "OR_upper")], caption = "Logistic Regression. Odds Ratio and Confidence Intervals for ICU Mortality-associated Factors. eICU Database")

or_table_gam <- or_icudeath_gam2 %>%
  select(term, OR, OR_lower, OR_upper) %>%
  mutate(
    term = factor(term, levels = variables_order),
    OR_upper = ifelse(OR_upper <= 100, sprintf("%.2f", OR_upper), sprintf("%.2f", OR_upper))
  ) %>%
  arrange(desc(term)) %>%
  kbl(caption = "GAM model. Odds Ratio and Confidence Intervals for ICU Mortality-associated Factors. eICU Database", align = "c") %>%
  kable_classic_2(full_width = F, html_font = "Cambria")

write.csv(or_table_gam, "C:/Users/cjimenez10J/Documents/projects/r_urgencias_sepsis/r_urgencias_sepsis/Figures/or_icudeath_gam2_eicu.csv")

## Create a data frame with all possible levels for adverse-protective-inconclusive variable
adverse_protective_levels_gam <- data.frame(adverse_protective = c("Adverse", "Protective", "Inconclusive"))

# Build the Forest plot
forest_plot_simple <- ggplot(or_icudeath_gam2, 
       aes(x = OR, xmin = OR_lower, xmax = OR_upper, y = term)) +
  geom_point(size = 2, aes(color = adverse_protective_gam)) +
  geom_errorbarh(height = 0.2, aes(color = adverse_protective_gam)) +
  geom_vline(xintercept = 1, linetype = "dashed") +
  labs(x = "Odds Ratio", y = NULL, title = "GAM model. Odds Ratio and Confidence Intervals\nfor Hospital Mortality-associated Factors. eICU Database") +
  theme_minimal() +
  scale_color_manual(
    values = c("Adverse" = "#c0392b", "Protective" = "#27ae60", "Inconclusive" = "#A5AAAC"),
  labels = c("Adverse", "Protective", "Inconclusive"),
    name = "Effect on Outcome",
    limits = adverse_protective_levels_gam$adverse_protective_gam) + #establishes limits of color scale
  scale_x_continuous(limits = c(0.5, 2.5)) +
  theme(
    plot.background = element_rect(fill = "white"),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(),
    plot.title = element_text(hjust = 0.5),
    legend.position = "top",
    axis.ticks = element_blank(),
    axis.text.x = element_text(color = "#2c3e50"),
    axis.text.y = element_text(color = "#2c3e50"
    ))

ggsave("C:/Users/cjimenez10J/Documents/projects/r_urgencias_sepsis/r_urgencias_sepsis/Figures/forestplot_gam_simple.png", plot = forest_plot_simple, width = 8, height = 6)
```

```{r}
# Crear un DataFrame con los OR y sus IC
or_data <- data.frame(
  term = c("(Intercept)", "vasopressors", "sexM", "age", "ethnicityAfrican American", 
           "ethnicityCaucasian", "ethnicityHispanic", "apachescoreIV", "final_charlson_score"),
  Estimate = c(-5.909371, 0.701841, -0.132430, 0.005472, 0.028170, 
               0.187701, -0.156909, 0.036773, 0.028466),
  Std_Error = c(0.228659, 0.071404, 0.068142, 0.002734, 0.169160, 
                0.135350, 0.210859, 0.001295, 0.013945)
)

# Calcular OR, IC Lower y IC Upper
or_data <- or_data %>%
  mutate(
    OR = exp(Estimate),
    OR_lower = exp(Estimate - 1.96 * Std_Error),
    OR_upper = exp(Estimate + 1.96 * Std_Error),
    adverse_protective_gam = case_when(
      OR_lower > 1 & OR_upper > 1 ~ "Adverse",
      OR_lower < 1 & OR_upper < 1 ~ "Protective",
      OR_lower <= 1 & OR_upper >= 1 ~ "Inconclusive"
    ),
    adverse_protective_gam = factor(adverse_protective_gam, levels = c("Adverse", "Protective", "Inconclusive"))
  )

# Construir el forest plot
ggplot(or_data, aes(x = OR, y = reorder(term, OR), xmin = OR_lower, xmax = OR_upper, color = adverse_protective_gam)) +
  geom_point(size = 3) +  # Punto para el OR
  geom_errorbarh(height = 0.2) +  # Barra de error para IC
  geom_vline(xintercept = 1, linetype = "dashed", color = "red") +  # Línea vertical en x = 1
  labs(x = "Odds Ratio", y = NULL, title = "Forest Plot of Odds Ratios and Confidence Intervals") +
  scale_color_manual(
    values = c("Adverse" = "#c0392b", "Protective" = "#27ae60", "Inconclusive" = "#A5AAAC"),
    labels = c("Adverse", "Protective", "Inconclusive"),
    name = "Effect on Outcome"
  ) +
  scale_x_continuous(limits = c(0, max(or_data$OR_upper) * 1.1)) +  # Ajustar los límites del eje x
  theme_minimal() +
  theme(
    plot.background = element_rect(fill = "white"),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(),
    plot.title = element_text(hjust = 0.5),
    axis.text.y = element_text(color = "#2c3e50"),
    axis.text.x = element_text(color = "#2c3e50"),
    axis.ticks = element_blank()
  )


```


### Calculo de las métricas de rendimiento con el 100% de los datos

```{r}
# Predicción usando el 100% de los datos
predictions_100 <- predict(gam_simple, newdata = final_df_er_sepsis, type = "response")
predictions_class_100 <- ifelse(predictions_100 > 0.5, 1, 0)

# Métricas de rendimiento
conf_matrix_100 <- confusionMatrix(as.factor(predictions_class_100), as.factor(final_df_er_sepsis$unitdischargestatus))

precision_100 <- conf_matrix_100$byClass['Pos Pred Value']
recall_100 <- conf_matrix_100$byClass['Sensitivity']
f1_100 <- F1_Score(as.numeric(final_df_er_sepsis$unitdischargestatus), predictions_class_100)
specificity_100 <- conf_matrix_100$byClass['Specificity']
accuracy_100 <- conf_matrix_100$overall['Accuracy']

# Imprimir resultados
print(conf_matrix_100)
print(paste("Precision: ", precision_100))
print(paste("Recall: ", recall_100))
print(paste("F1 Score: ", f1_100))
print(paste("Specificity: ", specificity_100))
print(paste("Accuracy: ", accuracy_100))

```
### Calculo de las métricas de rendimiento con 80% train y 20% test de los datos

```{r}
# Dividir los datos en 80% entrenamiento y 20% prueba
set.seed(123)  # Para reproducibilidad
trainIndex <- createDataPartition(final_df_er_sepsis$unitdischargestatus, p = 0.8, list = FALSE, times = 1)
trainData <- final_df_er_sepsis[trainIndex, ]
testData <- final_df_er_sepsis[-trainIndex, ]

# Entrenar el modelo con el conjunto de entrenamiento
gam_simple_train <- bam(unitdischargestatus ~ 
                    s(er_los_hrs, k=3) + 
                    vasopressors +
                    sex + 
                    ethnicity + 
                    apachescoreIV +  
                    final_charlson_score + 
                    hist_diabetes_bin +
                    hist_renal_bin + 
                    hist_cancer_bin + 
                    hist_chf_bin + 
                    hist_copd_bin + 
                    hist_other_bin,
                  data = final_df_er_sepsis,
                  family = binomial)

# Predicción en el conjunto de prueba
predictions_test <- predict(gam_simple_train, newdata = testData, type = "response")
predictions_class_test <- ifelse(predictions_test > 0.5, 1, 0)

# Métricas de rendimiento
conf_matrix_test <- confusionMatrix(as.factor(predictions_class_test), as.factor(testData$unitdischargestatus))

precision_test <- conf_matrix_test$byClass['Pos Pred Value']
recall_test <- conf_matrix_test$byClass['Sensitivity']
f1_test <- F1_Score(as.numeric(testData$unitdischargestatus), predictions_class_test)
specificity_test <- conf_matrix_test$byClass['Specificity']
accuracy_test <- conf_matrix_test$overall['Accuracy']

# Imprimir resultados
print(conf_matrix_test)
print(paste("Precision: ", precision_test))
print(paste("Recall: ", recall_test))
print(paste("F1 Score: ", f1_test))
print(paste("Specificity: ", specificity_test))
print(paste("Accuracy: ", accuracy_test))

```



```{r}
age_sex <- final_df_er_sepsis %>%
  select(sex, age, unitdischargestatus)

# Filtrar el dataframe para incluir solo las filas donde la edad está entre 16 y 50 años y unitdischargestatus es 1
filtered_df <- final_df_er_sepsis %>%
  select(sex, age, unitdischargestatus) %>%
  filter(age >= 51, age <= 90, unitdischargestatus == 1)

# Contar el número de hombres y mujeres en el dataframe filtrado
sex_counts <- table(filtered_df$sex)

# Imprimir los resultados
print(sex_counts)

```

