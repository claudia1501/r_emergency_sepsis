---
title: "03_modeling"
# output: html_document
---
```{r}
library(magrittr)
library(tableone)
library(kableExtra)
library(summarytools)
library(broom)
library(vroom)
library(stringr)
library(stringi)
library(mgcv)
library(parglm)
library(tibble)
library(tidyverse)
library(boot)
library(caTools)
library(caret)
library(pROC)
library(fastDummies)
library(forcats)
library(ggplot2)
library(stats)
library(survival)
library(ggsurvfit)
library(ggfortify)
library(tidymv)
```

# Load Data

```{r}
final_df_er_sepsis <- read.csv("C:/Users/cjimenez10J/Documents/projects/r_urgencias_sepsis/r_urgencias_sepsis/Figures/selected_data.csv")
message("Datos cargados correctamente")
```

# Discretizar er_los_hrs

```{r}
# Discretizar la variable de tiempo en intervalos de una hora
final_df_er_sepsis$er_los_hrs_d <- cut(final_df_er_sepsis$er_los_hrs, breaks = seq(0,6, by = 1), labels = FALSE)
final_df_er_sepsis$er_los_hrs_d[final_df_er_sepsis$er_los_hrs == 0] <- 0
final_df_er_sepsis$er_los_hrs_d[final_df_er_sepsis$er_los_hrs == 6] <- 6
# Determinar la cantidad de individuos a seleccionar por cada intervalo
individuals_per_interval <- floor(950*table(final_df_er_sepsis$er_los_hrs_d) / max(table(final_df_er_sepsis$er_los_hrs_d)))
# Ver cuantas observaciones hay en cada hora
final_df_er_sepsis %>%
  group_by(er_los_hrs_d) %>%
  summarise(n = n())
# Seleccionar individuos manteniendo la distribución original
selected_sample <- final_df_er_sepsis %>%
  group_by(er_los_hrs_d) %>%
  sample(size = individuals_per_interval, replace = FALSE)
```

# TRAIN
```{r}
# Crear un dataframe con datos balanceados:
set.seed(123)
datos_balance <- data.frame(sex=final_df_er_sepsis$sex,
                            age =final_df_er_sepsis$age,
                            ethnicity=final_df_er_sepsis$ethnicity,
                            er_los_hrs_d=final_df_er_sepsis$er_los_hrs_d,
                            apacheadmissiondx=final_df_er_sepsis$apacheadmissiondx,
                            unittype=final_df_er_sepsis$unittype, 
                            apachescoreIV=final_df_er_sepsis$apachescoreIV,
                            bact_resist_level=final_df_er_sepsis$bact_resist_level,
                            final_charlson_score=final_df_er_sepsis$final_charlson_score, 
                            hist_diabetes_bin=final_df_er_sepsis$hist_diabetes_bin,
                            hist_copd_bin=final_df_er_sepsis$hist_copd_bin,
                            hist_chf_bin=final_df_er_sepsis$hist_chf_bin,
                            hist_cancer_bin=final_df_er_sepsis$hist_cancer_bin,
                            hist_renal_bin=final_df_er_sepsis$hist_renal_bin,
                            hist_other_bin=final_df_er_sepsis$hist_other_bin,
                            unitdischargestatus = final_df_er_sepsis$unitdischargestatus)


datos_balance$unitdischargestatus_int <- as.integer(datos_balance$unitdischargestatus)
km_fit <- survfit(Surv(er_los_hrs_d, unitdischargestatus_int) ~ 1, data=datos_balance)
autoplot(km_fit)

# Dividir los datos en conjunto de entrenamiento y prueba:
set.seed(456)
data_train <- sample(nrow(datos_balance), 0.8 * nrow(datos_balance))

train <- datos_balance[data_train, ]
test <- datos_balance[-data_train, ]

# Ajustar el modelo gam:
modelo_gam_train <-  gam(
    unitdischargestatus ~ s(er_los_hrs, k=3) + sex + age + ethnicity + apachescoreIV +  final_charlson_score + hist_diabetes_bin + hist_renal_bin + hist_cancer_bin + hist_chf_bin + hist_copd_bin + hist_other_bin + unittype + apacheadmissiondx, data = train,
    family = binomial)

modelo_gam_test <- gam(
    unitdischargestatus ~ s(er_los_hrs, k=3) + sex + age + ethnicity + apachescoreIV +  final_charlson_score + hist_diabetes_bin + hist_renal_bin + hist_cancer_bin + hist_chf_bin + hist_copd_bin + hist_other_bin + unittype + apacheadmissiondx, data = test,
    family = binomial)
plot(modelo_gam_test)
plot(modelo_gam_train)
# Realizar predicciones y graficar el modelo:
predicciones <- predict(modelo_gam_train, newdata = test, type = "response")
plot(predicciones)

# Crear un gráfico para visualizar el modelo GAM en el conjunto de prueba
plot(modelo_gam_test, col = "blue", main = "Modelo GAM en Conjunto de Prueba")

# Graficar las predicciones contra las observaciones reales
points(test$er_los_hrs, predicciones, col = "red", pch = 16)

# Agregar leyendas y etiquetas
legend("topright", legend = c("Observaciones reales", "Predicciones"), col = c("blue", "red"), pch = c(1, 16))
xlabel <- expression("Tiempo en la sala de emergencias (horas)")
ylabel <- expression("Probabilidad de alta")
title <- "Modelo GAM y Predicciones en Conjunto de Prueba"
title(main = title, xlab = xlabel, ylab = ylabel)

# Mostrar el gráfico

```






# er_los_hrs: 6 horas

## FÓRMULA GAM
```{r}
#JUSTIFICACIÓN DE LA NO LINEALIDAD. Nos fijamos en la significación y en el Estimated degrees of freedom >1. Se utiliza para evaluar si la relación entre la variable de respuesta (unitdischargestatus: vivo o muerto) y la variable explicativa (er_los_hrs: tiempo en urgencias) es esencialmente lineal o si hay evidencias de no linealidad que podría ser capturada por la inclusión de términos suavizados
gam_mortality_unit_simple <- gam(unitdischargestatus ~ er_los_hrs + sex + age + ethnicity + apachescoreIV +  final_charlson_score + hist_diabetes_bin + hist_renal_bin + hist_cancer_bin + hist_chf_bin + hist_copd_bin + hist_other_bin + unittype + apacheadmissiondx, data = final_df_er_sepsis,
    family = binomial)

gam_mortality_unit <- 
  gam(
    unitdischargestatus ~ s(er_los_hrs, k=3) + sex + age + ethnicity + apachescoreIV +  final_charlson_score + hist_diabetes_bin + hist_renal_bin + hist_cancer_bin + hist_chf_bin + hist_copd_bin + hist_other_bin + unittype + apacheadmissiondx, data = final_df_er_sepsis,
    family = binomial)  #bact_resist_level    

anova(gam_mortality_unit_simple, gam_mortality_unit, test = "Chisq")
print(gam_mortality_unit)
plot(gam_mortality_unit,seWithMean = TRUE,shift = coef(gam_mortality_unit)[1], rug = TRUE, shade = TRUE, shade.col = "lightblue")



# seWithMean:A menudo es útil representar los errores estándar de un término de efecto parcial combinados con los errores estándar de la intersección del modelo. Esto se debe a que los intervalos de confianza en el valor medio de una variable pueden ser muy pequeños y no reflejan la incertidumbre general en nuestro modelo. El uso del argumento seWithMean añade esta incertidumbre.

# shift = coef(gam_mortality_unit)[1]: Para que los gráficos sean aún más interpretables, es útil cambiar la escala para que se incluya la intersección. Usando el argumento shift, podemos cambiar la escala por el valor de la intersección, que es el primer coeficiente del modelo. Observe cómo ha cambiado el eje Y. Ahora, el gráfico de efecto parcial tiene una interpretación más natural: nos muestra la predicción de la salida, asumiendo que otras variables están en su valor promedio.

#La variable “s(er_los_hrs:1.8)” parece ser una transformación suavizada de “er_los_hrs” que se utiliza en el modelo binomial con función de enlace logit para predecir la variable “unitdischargestatus” en función de varias variables independientes, incluyendo “sex”, “age”, “ethnicity”, “apachescoreIV”, “final_charlson_score”, “hist_diabetes_bin”, “hist_renal_bin”, “hist_cancer_bin”, “hist_chf_bin”, “hist_copd_bin”, “hist_other_bin”, “unittype” y “apacheadmissiondx”. La escala del eje Y, que va desde -0.4 a 0.2, representa los valores transformados suavizados del tiempo pasado en la sala de emergencias.

#La transformación suavizada se realiza mediante una función de suavizado que se ajusta a los datos de “er_los_hrs” y produce una curva suave que se ajusta a los datos. La función de suavizado utilizada en este caso parece tener 1.8 grados de libertad. La escala del eje Y se establece en función de los valores transformados suavizados de “er_los_hrs” y no de los valores originales de “er_los_hrs”.
```

## Modelos con dos suavizados (fija variable er_los_hrs)
```{r}
# Modelo GAM con age
gam_age_two_term <- gam(unitdischargestatus ~ s(er_los_hrs) + s(age) + sex + ethnicity + apachescoreIV +  final_charlson_score + hist_diabetes_bin + hist_renal_bin + hist_cancer_bin + hist_chf_bin + hist_copd_bin + hist_other_bin + unittype + apacheadmissiondx, data = final_df_er_sepsis,
    family = binomial)
summary(gam_age_two_term)
plot(gam_age_two_term)

# Modelo GAM con apachescoreIV
gam_apachescoreIV <- gam(unitdischargestatus ~ s(er_los_hrs) + s(apachescoreIV) + sex + ethnicity + age +  final_charlson_score + hist_diabetes_bin + hist_renal_bin + hist_cancer_bin + hist_chf_bin + hist_copd_bin + hist_other_bin + unittype  , data = final_df_er_sepsis,
    family = binomial)
summary(gam_apachescoreIV)
plot(gam_apachescoreIV)

#Modelo GAM final_charlson_score
gam_final_charlson_score <- gam(unitdischargestatus ~ s(er_los_hrs) + s(final_charlson_score) + sex + ethnicity + age + apachescoreIV + hist_diabetes_bin + hist_renal_bin + hist_cancer_bin + hist_chf_bin + hist_copd_bin + hist_other_bin + unittype + apacheadmissiondx, data = final_df_er_sepsis,
    family = binomial)
summary(gam_final_charlson_score)
plot(gam_final_charlson_score)

#Modelo GAM final_charlson_score y apache
gam_apache_charlson_score <- gam(unitdischargestatus ~ s(er_los_hrs) + s(final_charlson_score) + s(apachescoreIV) + sex + ethnicity + age  + hist_diabetes_bin + hist_renal_bin + hist_cancer_bin + hist_chf_bin + hist_copd_bin + hist_other_bin + unittype + apacheadmissiondx, data = final_df_er_sepsis,
    family = binomial)
summary(gam_apache_charlson_score)
plot(gam_apache_charlson_score)

#Modelo GAM final_charlson_score y age
gam_charlson_age <- gam(unitdischargestatus ~ s(er_los_hrs) + s(final_charlson_score) + s(age) + sex + ethnicity + apachescoreIV  + hist_diabetes_bin + hist_renal_bin + hist_cancer_bin + hist_chf_bin + hist_copd_bin + hist_other_bin + unittype + apacheadmissiondx, data = final_df_er_sepsis,
    family = binomial)
summary(gam_charlson_age)
plot(gam_charlson_age)

#Modelo GAM apache y age
gam_apache_age <- gam(unitdischargestatus ~ s(er_los_hrs) + s(apachescoreIV) + s(age) + sex + ethnicity + final_charlson_score + hist_diabetes_bin + hist_renal_bin + hist_cancer_bin + hist_chf_bin + hist_copd_bin + hist_other_bin + unittype + apacheadmissiondx, data = final_df_er_sepsis,
    family = binomial)
summary(gam_apache_age)
plot(gam_apache_age)

#Modelo GAM apache, age, charlson
gam_apache_age_charlson <- gam(unitdischargestatus ~ s(er_los_hrs, by=sex) + s(apachescoreIV) + s(age) + s(final_charlson_score)+ sex + ethnicity + hist_diabetes_bin + hist_renal_bin + hist_cancer_bin + hist_chf_bin + hist_copd_bin + hist_other_bin + unittype + apacheadmissiondx, data = final_df_er_sepsis,
    family = binomial)
summary(gam_apache_age_charlson)
plot(gam_apache_age_charlson)

#ANOVA
anova(gam_mortality_unit,gam_apache_age_charlson,gam_apache_age,gam_charlson_age,gam_apache_charlson_score,gam_final_charlson_score,gam_apachescoreIV,gam_age_two_term, test = "Chisq")

anova(gam_mortality_unit,gam_apache_age_charlson,test = "Chisq")
anova(gam_mortality_unit,gam_apache_age,test = "Chisq")
anova(gam_mortality_unit,gam_charlson_age,test = "Chisq")
anova(gam_mortality_unit,gam_apache_charlson_score,test = "Chisq")
anova(gam_mortality_unit,gam_final_charlson_score,test = "Chisq")
anova(gam_mortality_unit,gam_apachescoreIV,test = "Chisq")
anova(gam_mortality_unit,gam_age_two_term,test = "Chisq")


vis.gam(gam_mortality_unit, view = c("er_los_hrs", "age"),theta = 30, n.grid = 120, border = NA)
```

## Odds Ratio and forest plot df total
The model's coefficients, odds ratios, and corresponding confidence intervals were then extracted to generate a forest plot, offering a concise visual representation of the estimated odds ratios and their precision intervals for each predictor variable. The GAM approach provides a robust framework to explore the complex relationships between multiple predictors and a binary health outcome, facilitating a comprehensive analysis in the field of public health research.

```{r}
coef_data <- data.frame(coef = coef(gam_mortality_unit))
se <- sqrt(diag(vcov(gam_mortality_unit)))
z_value <- qnorm(0.95) # 95% confidence level - detection prevalence
#Redondea decimales a 2

coef_data <- round(coef_data, 2)

# Calculate the odds ratios and their respective lower and upper confidence limits
coef_data$OR <- exp(coef_data$coef)
coef_data$OR_lower <- exp(coef_data$coef - z_value * se)  # Usar 0.975 para obtener IC del 95%
coef_data$OR_upper <- exp(coef_data$coef + z_value * se)

# Filtrar las variables de interés
#coef_data2 <- coef_data %>%
#  filter(predictor != "(Intercept)")

# Calcular la categoría (Adverse, Protective, Inconclusive)
coef_data <- coef_data %>%
  mutate(
    adverse_protective = case_when(
      OR_lower > 1 & OR_upper > 1 ~ "Adverse",
      OR_lower < 1 & OR_upper < 1 ~ "Protective",
      TRUE ~ "Inconclusive"
    )
  )
coef_data$adverse_protective <- as.factor(coef_data$adverse_protective)

# Crear el forest plot
forest_plot <- ggplot(coef_data, aes(x = OR, xmin = OR_lower, xmax = OR_upper, y = rownames(coef_data))) +
  geom_point(aes(color = adverse_protective), size = 3) +
  geom_errorbarh(aes(color = adverse_protective), height = 0.1, linewidth = 0.5) +
  geom_vline(xintercept = 1, linetype = "solid", color = "gray50") +
  labs(
    x = "Odds Ratio (with 95% Confidence Interval)",
    y = "Predictor Variable",
    title = "Odds Ratios and Confidence Intervals for mortality emergency sepsis ICU"
  ) +
  scale_color_manual(values = c("Adverse" = "#c0392b", "Protective" = "#27ae60", "Inconclusive" = "gray70")) +
  theme_minimal() 

print(forest_plot)

```

```{r}

final_df_er_sepsis$unitdischargestatus_int <- as.integer(final_df_er_sepsis$unitdischargestatus)
km_fit <- survfit(Surv(er_los_hrs_b, unitdischargestatus) ~ 1, data=final_df_er_sepsis)
autoplot(km_fit)


```





# GAM PLOT
## Explicación gráficas:
EJE Y
1º Gráfica (gam_plot_mortality_unit): representa el fit (logaritmo de razón de probabilidad) es la manera en que el modelo GAM representa la relación entre la variable predictora 'er_los_hrs' y la variable respuesta 'mortalidad' (unitdischargestatus). Ofrece resultados directos de la estimación del GAM. INTERPRETACIÓN: Un valor negativo de fit indica una disminución en el logaritmo de la razón de probabilidades, lo que podría asociarse con una disminución en la probabilidad de mortalidad. Un valor positivo indica un aumento en la probabilidad logarítmica de mortalidad.
2º Grágica (df_er_los_hrs_mortality): representa fit_chance (probabilidad tras la transformación logística).Uso de fórmula sigmoide, valores entre 0 y 1

```{r}
# Variable er_los_hrs
gam_plot_mortality_unit <-plot(gam_mortality_unit, rug = TRUE,scale = 0)
x <- gam_plot_mortality_unit[[1]]$x
fit <- gam_plot_mortality_unit[[1]]$fit
se <- gam_plot_mortality_unit[[1]]$se

fit_values <- as.vector(fit)
se_values <- as.vector(se)


# Convert odds ratio to percentage chance of ICU mortality 
fit_chance <- (exp(fit) / (1 + exp(fit))) 
lower_bound_chance <- (exp(fit - 2 * se) / (1 + exp(fit - 2 * se))) 
upper_bound_chance <- (exp(fit + 2 * se) / (1 + exp(fit + 2 * se))) 


df_er_los_hrs_mortality <- 
  data.frame(
    x = x, y = fit_chance,
    ymin = lower_bound_chance , ymax = upper_bound_chance
  )

ggplot(df_er_los_hrs_mortality, mapping = aes(x = x, y = fit_chance)) +
  geom_ribbon(aes(ymin = lower_bound_chance, ymax = upper_bound_chance), alpha = 0.3) +
  geom_line(color = "blue") +  # Añade la línea de ajuste
  labs(
    x = "Emergency Room Length of Stay (hours)", 
    y = "Mortality in the ICU probability (%)", 
    title = "Generative Additive Modeling"
  ) +
  theme_minimal() +
  theme(
    strip.text = element_text(face = "italic"),
    panel.border = element_rect(color = "black", fill = NA, size = 0.6),
    legend.position = "none"
  ) +
  ylim(0.2, 1)

ggplot(df_er_los_hrs_mortality, mapping = aes(x = x, y = fit_chance)) +
  stat_smooth(method = gam, formula = y ~ s(x)) +
  geom_ribbon(aes(ymin = lower_bound_chance, ymax = upper_bound_chance), alpha = 0.3) +
   labs(
    x = "Emergency Room Length of Stay (hours)", 
    y = "Mortality in the ICU probability (%)", 
    title = "Generative Additive Modeling"
  ) +
  theme_minimal()



```

# Análisis de mortalidad y estancia en ugencia (er_los_hrs: 2,4 y 6 horas)
```{r}
# 2 horas
df_mortality_2hrs <- final_df_er_sepsis %>%
  select(er_los_hrs, unitdischargestatus)

df_mortality_2hrs <- df_mortality_2hrs %>%
  filter(er_los_hrs <= 2) 
perc_mortality_2hrs <- sum(df_mortality_2hrs$unitdischargestatus == 1) / nrow(df_mortality_2hrs)*100


df_mortality_4hrs <- final_df_er_sepsis %>%
  select(er_los_hrs, unitdischargestatus)

df_mortality_4hrs <- df_mortality_4hrs %>%
  filter(er_los_hrs <= 4) %>%
   filter(er_los_hrs > 2)
perc_mortality_4hrs <- sum(df_mortality_4hrs$unitdischargestatus == 1) / nrow(df_mortality_4hrs)*100

df_mortality_6hrs <- final_df_er_sepsis %>%
  select(er_los_hrs, unitdischargestatus)

df_mortality_6hrs <- df_mortality_6hrs %>%
  filter(er_los_hrs <= 6) %>%
   filter(er_los_hrs > 4)

perc_mortality_6hrs <- sum(df_mortality_6hrs$unitdischargestatus == 1) / nrow(df_mortality_6hrs)*100

summary(df_mortality_2hrs)
summary(df_mortality_4hrs)
summary(df_mortality_6hrs)

print(perc_mortality_2hrs)
print(perc_mortality_4hrs)
print(perc_mortality_6hrs)

# Asegurarse de que ambos dataframes tengan el mismo número de filas
min_rows <- min(nrow(df_mortality_2hrs), nrow(df_mortality_4hrs), nrow(df_mortality_6hrs))
df1_subset <- df_mortality_2hrs[1:min_rows, ]
df2_subset <- df_mortality_4hrs[1:min_rows, ]
df3_subset <- df_mortality_6hrs[1:min_rows, ]
# Combinar solo la columna de interés en un único objeto de datos
combined_values <- c(df1_subset$er_los_hrs, df2_subset$er_los_hrs, df3_subset$er_los_hrs)
combined_groups <- rep(c("2", "4", "6"), each = min_rows)
# Crear el boxplot
boxplot(combined_values ~ combined_groups,
        col = c("skyblue", "lightgreen"),
        main = "Boxplot Comparativo",
        xlab = "Grupo",
        ylab = "Valor")

```

# er_los_hrs y unitdischargestatus
```{r}
# Asegurarse de que ambos dataframes tengan el mismo número de filas
min_rows <- min(nrow(df_mortality_2hrs), nrow(df_mortality_4hrs), nrow(df_mortality_6hrs))
df1_subset <- df_mortality_2hrs[1:min_rows, ]
df2_subset <- df_mortality_4hrs[1:min_rows, ]
df3_subset <- df_mortality_6hrs[1:min_rows, ]
# Combinar solo la columna de interés en un único objeto de datos
combined_values <- c(df1_subset$er_los_hrs, df2_subset$er_los_hrs, df3_subset$er_los_hrs)
combined_groups <- rep(c("2", "4", "6"), each = min_rows)
combined_dicotomica <- c(df1_subset$unitdischargestatus, df2_subset$unitdischargestatus,df3_subset$unitdischargestatus)
# Crear el boxplot
boxplot(combined_values ~ interaction(combined_groups, combined_dicotomica),
        col = c("skyblue", "lightgreen"),
        main = "Boxplot Comparativo",
        xlab = "Grupo",
        ylab = "Valor")
```

# Comparación distribuciones entre las 2,4 y 6 horas
```{r}
df_mortality_hrs_2full <- final_df_er_sepsis %>%
  filter(er_los_hrs <= 2)

df_mortality_4full <- final_df_er_sepsis %>%
  filter(er_los_hrs <= 4)

df_mortality_6full <- final_df_er_sepsis %>%
  filter(er_los_hrs <= 6)

# Función para realizar la prueba de Kolmogorov-Smirnov entre dos DataFrames
ks_test_between_dfs <- function(df1, df2) {
  p_values <- sapply(seq_along(df1), function(i) {
    ks_test_result <- ks.test(df1[, i], df2[, i])
    return(ks_test_result$p.value)
  })
  return(p_values)
}

# Realiza la prueba de Kolmogorov-Smirnov para cada par de DataFrames
p_values_df1_df2 <- ks.test(df_mortality_hrs_2full, df_mortality_4full)
p_values_df1_df3 <- ks.test(df_mortality_2full, df_mortality_6full)
p_values_df2_df3 <- ks_test_between_dfs(df_mortality_4full, df_mortality_6full)

# Combina los p-valores usando la prueba de Bonferroni
alpha <- 0.05
adjusted_p_values <- p.adjust(c(p_values_df1_df2, p_values_df1_df3, p_values_df2_df3), method = "bonferroni")

# Muestra los p-valores ajustados
print(adjusted_p_values)
```


# Análisis de mortalidad y estancia en urgencia (er_los_hrs: 2, 4 y 6 horas)
```{r}

# 2 horas
df_mortality_2hrs <- final_df_er_sepsis %>%
  filter(er_los_hrs <= 2)

# 4 horas
df_mortality_4hrs <- final_df_er_sepsis %>%
  filter(er_los_hrs <= 4)

# 6 horas
df_mortality_6hrs <- final_df_er_sepsis %>%
  filter(er_los_hrs <= 6)

# Resumen de las DataFrames
summary(df_mortality_2hrs)
summary(df_mortality_4hrs)
summary(df_mortality_6hrs)

# Asegurarse de que ambos dataframes tengan el mismo número de filas
min_rows <- min(nrow(df_mortality_2hrs), nrow(df_mortality_4hrs), nrow(df_mortality_6hrs))
df1_subset <- df_mortality_2hrs[1:min_rows, ]
df2_subset <- df_mortality_4hrs[1:min_rows, ]
df3_subset <- df_mortality_6hrs[1:min_rows, ]

# Combinar solo la columna de interés en un único objeto de datos
combined_df <- c(df1_subset$er_los_hrs, df2_subset$er_los_hrs, df3_subset$er_los_hrs)
combined_groups <- rep(c("2", "4", "6"), each = min_rows)












# Conteo de muertes en cada tramo de hora
death_count <- table(cut(combined_values, breaks = c(0, 2, 4, 6), include.lowest = TRUE))

# Crear el boxplot
bp <- boxplot(combined_values ~ combined_groups,
              col = c("skyblue", "lightgreen"),
              main = "Boxplot Comparativo",
              xlab = "Grupo",
              ylab = "Valor")

# Conteo de muertes en cada tramo de hora
death_count <- table(cut(combined_values, breaks = c(0, 2, 4, 6), include.lowest = TRUE))

# Añadir el conteo de muertes en cada tramo de hora dentro de las cajas del boxplot
text(x = c(1, 2, 3), y = max(combined_values) - 0.5, labels = paste("Muertes: ", death_count), pos = 3,col = "red", font = 2) 

# Añadir etiquetas con estadísticos del boxplot
text(x = bp$stats[, 1], y = 1.25, 
     labels = round(bp$stats[, 1], 2), pos = 2, col = "black", font = 2)

```

# Pruebas de rendimiento del modelo GAM
```{r}
predicciones <- predict(gam_mortality_unit, type = "response")
clases_predichas <- ifelse(predicciones > 0.5,1,0)
matriz_confusion <- table( Actual = final_df_er_sepsis$unitdischargestatu, predicha = clases_predichas)
precission <- (matriz_confusion[2, 2] + matriz_confusion[1, 1]) / sum(matriz_confusion)
recall <- matriz_confusion[2, 2] / sum(matriz_confusion[2, ])
f1_score <- 2 * (precission * recall) / (precission + recall)

especificidad <- matriz_confusion[1, 1] / sum(matriz_confusion[1, ])
exactitud <- (matriz_confusion[1, 1] + matriz_confusion[2, 2]) / sum(matriz_confusion)


print(precission)
print(recall)
print(f1_score)
print(especificidad)
print(exactitud)
print(matriz_confusion)
```







